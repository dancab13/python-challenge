# Module 3 Challenge - PyBank# Import the standard modulesimport osimport csv# Import the csv file and make sure Python can read it using the csv library or module.bank = os.path.join('Resources', 'budget_data.csv')with open(bank) as csvfile:        # Initiatlize the csv file and define it    budget = (csv.reader(csvfile, delimiter=','))        # Store the header row     csv_header = next(budget)        #Define variables    row_list = []    date_list = []    net_list = []    changes = []    previous_row = None    increase_row = None    decrease_row = None        # Loop through the rows    for row in budget:                # As the code loops through each row, add a 1 for each row to the empty        ## list created above, then add the contents of the list        row_list.append(1)        rows = sum(row_list)                # Save the date column as its own list; this will be helpful later        date_list.append(row[0])                # Add the value of the second column to the empty list created above,         ## then add the contents of the list        net_list.append(int(row[1]))        net_total = sum(net_list)                # Xpert Assistant helped me hone this code below                # Set the value of the current row as the value of the row(s) in the        ## second column, and store that value as the current_row variable        current_row = int(row[1])                # Set a conditional that if the previous row in the loop is not None        ## (which we already defined above, and the value will not be None)        ## then subtract the current row from the previous row and add the it        ## to the empty list created above        if previous_row is not None:            change = current_row - previous_row            changes.append(change)        previous_row = current_row        # Add 0 to the front of the changes list (this will be helpful    ## later when you need to find the index of the max and min and the lists    ## need the same amount of rows)    changes.insert(0, 0)        # Create a new variable to hold the sum of the list of subtracted values    ## and create a new variable to hold the average, which is the subtracted    ## values divided by the number of rows (already found) minus 1 because    ## you can't subtract the first row (when current) from the previous row    ## because the previous row is the header, so there's one fewer row than    ## in the loop    yearly_change = sum(changes)    average_change = yearly_change/(rows-1)        # Find the maximum and minumum of the changes in profit/loss by using the    ## built-in max and min functions, and store that data in new variables        maximum = max(changes)    minimum = min(changes)        # Find the index (i.e., the row number) of the max and min, and use that    ## index number to store the corresponding data of the adjacent columns    ## in new variables    max_index = changes.index(maximum)    max_date = date_list[max_index]    min_index = changes.index(minimum)    min_date = date_list[min_index]        # Print outputs in the terminal...    results = (f"\nFinancial Analysis\n\n----------------------------\n"    f"\nTotal rows: {rows}\n"    f"\nTotal: ${net_total}\n"    f"\nAverage change: ${round(average_change, 2)}\n"    f"\nGreatest Increase in Profits: {max_date} (${maximum})\n"    f"\nGreatest Decrease in Profits: {min_date} (${minimum})\n"    )        print(results)    # ...and as a new .txt fileoutput_path = (os.path.join("analysis", "PyBank_Results.txt"))with open(output_path, "w") as text_file:    print(f"{results}", file=text_file)